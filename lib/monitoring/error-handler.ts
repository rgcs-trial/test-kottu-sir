/**\n * Comprehensive error handling and monitoring system\n * for Stripe payment processing\n */\n\nimport { logSecurityEvent, SecurityEventType } from '@/lib/security/validation'\n\n// ===== ERROR TYPES =====\n\nexport enum PaymentErrorType {\n  // Stripe-specific errors\n  STRIPE_API_ERROR = 'stripe_api_error',\n  STRIPE_CARD_ERROR = 'stripe_card_error',\n  STRIPE_RATE_LIMIT_ERROR = 'stripe_rate_limit_error',\n  STRIPE_AUTHENTICATION_ERROR = 'stripe_authentication_error',\n  STRIPE_CONNECTION_ERROR = 'stripe_connection_error',\n  \n  // Payment processing errors\n  PAYMENT_INTENT_CREATION_FAILED = 'payment_intent_creation_failed',\n  PAYMENT_CONFIRMATION_FAILED = 'payment_confirmation_failed',\n  PAYMENT_AMOUNT_MISMATCH = 'payment_amount_mismatch',\n  INVALID_PAYMENT_METHOD = 'invalid_payment_method',\n  \n  // Connect account errors\n  CONNECT_ACCOUNT_NOT_FOUND = 'connect_account_not_found',\n  CONNECT_ACCOUNT_RESTRICTED = 'connect_account_restricted',\n  CONNECT_ONBOARDING_FAILED = 'connect_onboarding_failed',\n  \n  // Security errors\n  SUSPICIOUS_ACTIVITY = 'suspicious_activity',\n  RATE_LIMIT_EXCEEDED = 'rate_limit_exceeded',\n  WEBHOOK_VERIFICATION_FAILED = 'webhook_verification_failed',\n  \n  // System errors\n  DATABASE_ERROR = 'database_error',\n  VALIDATION_ERROR = 'validation_error',\n  CONFIGURATION_ERROR = 'configuration_error',\n  NETWORK_ERROR = 'network_error',\n}\n\nexport interface PaymentError {\n  type: PaymentErrorType\n  message: string\n  code?: string\n  statusCode?: number\n  details?: Record<string, any>\n  timestamp: string\n  requestId?: string\n  userId?: string\n  restaurantId?: string\n  paymentIntentId?: string\n  stack?: string\n  retryable: boolean\n  severity: 'low' | 'medium' | 'high' | 'critical'\n}\n\n// ===== ERROR CLASSIFICATION =====\n\n/**\n * Classify Stripe errors\n */\nexport function classifyStripeError(error: any): PaymentError {\n  const baseError: Partial<PaymentError> = {\n    timestamp: new Date().toISOString(),\n    details: {\n      stripeCode: error.code,\n      stripeType: error.type,\n      stripeDeclineCode: error.decline_code,\n      stripeParam: error.param,\n    },\n  }\n  \n  switch (error.type) {\n    case 'card_error':\n      return {\n        ...baseError,\n        type: PaymentErrorType.STRIPE_CARD_ERROR,\n        message: error.message || 'Card payment failed',\n        code: error.code,\n        statusCode: 402,\n        retryable: ['generic_decline', 'insufficient_funds'].includes(error.code) ? false : true,\n        severity: 'low',\n      } as PaymentError\n    \n    case 'api_error':\n      return {\n        ...baseError,\n        type: PaymentErrorType.STRIPE_API_ERROR,\n        message: error.message || 'Stripe API error',\n        code: error.code,\n        statusCode: 500,\n        retryable: true,\n        severity: 'high',\n      } as PaymentError\n    \n    case 'rate_limit_error':\n      return {\n        ...baseError,\n        type: PaymentErrorType.STRIPE_RATE_LIMIT_ERROR,\n        message: 'Rate limit exceeded',\n        statusCode: 429,\n        retryable: true,\n        severity: 'medium',\n      } as PaymentError\n    \n    case 'authentication_error':\n      return {\n        ...baseError,\n        type: PaymentErrorType.STRIPE_AUTHENTICATION_ERROR,\n        message: 'Stripe authentication failed',\n        statusCode: 401,\n        retryable: false,\n        severity: 'critical',\n      } as PaymentError\n    \n    default:\n      return {\n        ...baseError,\n        type: PaymentErrorType.STRIPE_API_ERROR,\n        message: error.message || 'Unknown Stripe error',\n        statusCode: 500,\n        retryable: true,\n        severity: 'medium',\n      } as PaymentError\n  }\n}\n\n/**\n * Classify general payment errors\n */\nexport function classifyPaymentError(\n  error: any,\n  context: {\n    operation: string\n    userId?: string\n    restaurantId?: string\n    paymentIntentId?: string\n  }\n): PaymentError {\n  const baseError: Partial<PaymentError> = {\n    timestamp: new Date().toISOString(),\n    userId: context.userId,\n    restaurantId: context.restaurantId,\n    paymentIntentId: context.paymentIntentId,\n    details: {\n      operation: context.operation,\n      originalError: error.message,\n    },\n  }\n  \n  // Check if it's a Stripe error first\n  if (error.type && ['card_error', 'api_error', 'rate_limit_error', 'authentication_error'].includes(error.type)) {\n    return classifyStripeError(error)\n  }\n  \n  // Check for specific error messages or codes\n  if (error.message?.includes('not found')) {\n    return {\n      ...baseError,\n      type: PaymentErrorType.CONNECT_ACCOUNT_NOT_FOUND,\n      message: 'Resource not found',\n      statusCode: 404,\n      retryable: false,\n      severity: 'low',\n    } as PaymentError\n  }\n  \n  if (error.message?.includes('rate limit')) {\n    return {\n      ...baseError,\n      type: PaymentErrorType.RATE_LIMIT_EXCEEDED,\n      message: 'Rate limit exceeded',\n      statusCode: 429,\n      retryable: true,\n      severity: 'medium',\n    } as PaymentError\n  }\n  \n  if (error.message?.includes('validation')) {\n    return {\n      ...baseError,\n      type: PaymentErrorType.VALIDATION_ERROR,\n      message: error.message || 'Validation failed',\n      statusCode: 400,\n      retryable: false,\n      severity: 'low',\n    } as PaymentError\n  }\n  \n  if (error.message?.includes('database') || error.code?.includes('DB')) {\n    return {\n      ...baseError,\n      type: PaymentErrorType.DATABASE_ERROR,\n      message: 'Database operation failed',\n      statusCode: 500,\n      retryable: true,\n      severity: 'high',\n    } as PaymentError\n  }\n  \n  // Default error\n  return {\n    ...baseError,\n    type: PaymentErrorType.STRIPE_API_ERROR,\n    message: error.message || 'Payment processing failed',\n    statusCode: 500,\n    retryable: true,\n    severity: 'medium',\n    stack: error.stack,\n  } as PaymentError\n}\n\n// ===== ERROR HANDLING =====\n\n/**\n * Enhanced error logger with structured data\n */\nexport class PaymentErrorLogger {\n  private static instance: PaymentErrorLogger\n  private errors: PaymentError[] = []\n  \n  static getInstance(): PaymentErrorLogger {\n    if (!PaymentErrorLogger.instance) {\n      PaymentErrorLogger.instance = new PaymentErrorLogger()\n    }\n    return PaymentErrorLogger.instance\n  }\n  \n  /**\n   * Log payment error with context\n   */\n  logError(\n    error: any,\n    context: {\n      operation: string\n      userId?: string\n      restaurantId?: string\n      paymentIntentId?: string\n      requestId?: string\n      userAgent?: string\n      ip?: string\n    }\n  ): PaymentError {\n    const paymentError = classifyPaymentError(error, context)\n    paymentError.requestId = context.requestId\n    \n    // Store error\n    this.errors.push(paymentError)\n    \n    // Log to console with structured format\n    const logEntry = {\n      level: this.getLogLevel(paymentError.severity),\n      timestamp: paymentError.timestamp,\n      error: {\n        type: paymentError.type,\n        message: paymentError.message,\n        code: paymentError.code,\n        statusCode: paymentError.statusCode,\n        retryable: paymentError.retryable,\n      },\n      context: {\n        operation: context.operation,\n        userId: context.userId ? `user_***${context.userId.slice(-4)}` : undefined,\n        restaurantId: context.restaurantId ? `rest_***${context.restaurantId.slice(-4)}` : undefined,\n        paymentIntentId: paymentError.paymentIntentId ? `pi_***${paymentError.paymentIntentId.slice(-4)}` : undefined,\n        requestId: context.requestId,\n        userAgent: context.userAgent,\n        ip: context.ip,\n      },\n      details: paymentError.details,\n    }\n    \n    // Log based on severity\n    switch (paymentError.severity) {\n      case 'critical':\n        console.error('CRITICAL PAYMENT ERROR:', JSON.stringify(logEntry, null, 2))\n        break\n      case 'high':\n        console.error('HIGH SEVERITY PAYMENT ERROR:', JSON.stringify(logEntry, null, 2))\n        break\n      case 'medium':\n        console.warn('PAYMENT WARNING:', JSON.stringify(logEntry, null, 2))\n        break\n      case 'low':\n        console.info('PAYMENT INFO:', JSON.stringify(logEntry, null, 2))\n        break\n    }\n    \n    // Log security events for suspicious activities\n    if (paymentError.type === PaymentErrorType.SUSPICIOUS_ACTIVITY) {\n      logSecurityEvent(\n        SecurityEventType.SUSPICIOUS_PAYMENT,\n        {\n          ...context,\n          error: paymentError,\n        },\n        paymentError.severity\n      )\n    }\n    \n    // TODO: In production, send to monitoring service\n    // this.sendToMonitoringService(paymentError, context)\n    \n    return paymentError\n  }\n  \n  /**\n   * Log successful operations for monitoring\n   */\n  logSuccess(\n    operation: string,\n    context: {\n      userId?: string\n      restaurantId?: string\n      paymentIntentId?: string\n      requestId?: string\n      duration?: number\n      amount?: number\n    }\n  ): void {\n    const logEntry = {\n      level: 'info',\n      timestamp: new Date().toISOString(),\n      operation,\n      success: true,\n      context: {\n        ...context,\n        userId: context.userId ? `user_***${context.userId.slice(-4)}` : undefined,\n        restaurantId: context.restaurantId ? `rest_***${context.restaurantId.slice(-4)}` : undefined,\n        paymentIntentId: context.paymentIntentId ? `pi_***${context.paymentIntentId.slice(-4)}` : undefined,\n      },\n    }\n    \n    console.info('PAYMENT SUCCESS:', JSON.stringify(logEntry, null, 2))\n  }\n  \n  /**\n   * Get recent errors for debugging\n   */\n  getRecentErrors(count = 100): PaymentError[] {\n    return this.errors.slice(-count)\n  }\n  \n  /**\n   * Get error statistics\n   */\n  getErrorStats(timeframe = 3600000): {\n    total: number\n    byType: Record<string, number>\n    bySeverity: Record<string, number>\n  } {\n    const cutoff = Date.now() - timeframe\n    const recentErrors = this.errors.filter(\n      error => new Date(error.timestamp).getTime() > cutoff\n    )\n    \n    const byType: Record<string, number> = {}\n    const bySeverity: Record<string, number> = {}\n    \n    recentErrors.forEach(error => {\n      byType[error.type] = (byType[error.type] || 0) + 1\n      bySeverity[error.severity] = (bySeverity[error.severity] || 0) + 1\n    })\n    \n    return {\n      total: recentErrors.length,\n      byType,\n      bySeverity,\n    }\n  }\n  \n  private getLogLevel(severity: string): string {\n    switch (severity) {\n      case 'critical':\n        return 'error'\n      case 'high':\n        return 'error'\n      case 'medium':\n        return 'warn'\n      case 'low':\n        return 'info'\n      default:\n        return 'info'\n    }\n  }\n}\n\n// ===== RETRY LOGIC =====\n\nexport interface RetryConfig {\n  maxRetries: number\n  baseDelay: number\n  maxDelay: number\n  backoffMultiplier: number\n  retryableErrors: PaymentErrorType[]\n}\n\nconst defaultRetryConfig: RetryConfig = {\n  maxRetries: 3,\n  baseDelay: 1000, // 1 second\n  maxDelay: 30000, // 30 seconds\n  backoffMultiplier: 2,\n  retryableErrors: [\n    PaymentErrorType.STRIPE_API_ERROR,\n    PaymentErrorType.STRIPE_RATE_LIMIT_ERROR,\n    PaymentErrorType.STRIPE_CONNECTION_ERROR,\n    PaymentErrorType.NETWORK_ERROR,\n    PaymentErrorType.DATABASE_ERROR,\n  ],\n}\n\n/**\n * Retry function with exponential backoff\n */\nexport async function retryWithBackoff<T>(\n  operation: () => Promise<T>,\n  context: {\n    operationName: string\n    userId?: string\n    restaurantId?: string\n    paymentIntentId?: string\n  },\n  config: Partial<RetryConfig> = {}\n): Promise<T> {\n  const finalConfig = { ...defaultRetryConfig, ...config }\n  const logger = PaymentErrorLogger.getInstance()\n  \n  let lastError: any\n  \n  for (let attempt = 0; attempt <= finalConfig.maxRetries; attempt++) {\n    try {\n      const result = await operation()\n      \n      // Log success if this was a retry\n      if (attempt > 0) {\n        logger.logSuccess(`${context.operationName}_retry_success`, {\n          ...context,\n          attempt,\n        })\n      }\n      \n      return result\n    } catch (error) {\n      lastError = error\n      \n      const paymentError = classifyPaymentError(error, {\n        operation: context.operationName,\n        ...context,\n      })\n      \n      // Check if error is retryable\n      if (!paymentError.retryable || !finalConfig.retryableErrors.includes(paymentError.type)) {\n        logger.logError(error, {\n          operation: `${context.operationName}_non_retryable`,\n          ...context,\n        })\n        throw error\n      }\n      \n      // Don't retry if this was the last attempt\n      if (attempt === finalConfig.maxRetries) {\n        logger.logError(error, {\n          operation: `${context.operationName}_max_retries_exceeded`,\n          ...context,\n        })\n        throw error\n      }\n      \n      // Calculate delay with exponential backoff and jitter\n      const delay = Math.min(\n        finalConfig.baseDelay * Math.pow(finalConfig.backoffMultiplier, attempt),\n        finalConfig.maxDelay\n      )\n      \n      // Add jitter to prevent thundering herd\n      const jitteredDelay = delay + (Math.random() * 1000)\n      \n      logger.logError(error, {\n        operation: `${context.operationName}_retry_attempt_${attempt + 1}`,\n        ...context,\n      })\n      \n      // Wait before retrying\n      await new Promise(resolve => setTimeout(resolve, jitteredDelay))\n    }\n  }\n  \n  throw lastError\n}\n\n// ===== MONITORING UTILITIES =====\n\n/**\n * Health check for payment system\n */\nexport async function checkPaymentSystemHealth(): Promise<{\n  healthy: boolean\n  checks: Record<string, boolean>\n  errors: string[]\n}> {\n  const checks: Record<string, boolean> = {}\n  const errors: string[] = []\n  \n  try {\n    // Check Stripe API connectivity\n    const { stripe } = await import('@/lib/stripe/server')\n    await stripe.paymentIntents.list({ limit: 1 })\n    checks.stripe_api = true\n  } catch (error) {\n    checks.stripe_api = false\n    errors.push('Stripe API unreachable')\n  }\n  \n  try {\n    // Check environment configuration\n    const { validateEnvironment } = await import('@/lib/security/validation')\n    const envCheck = validateEnvironment()\n    checks.environment = envCheck.isValid\n    if (!envCheck.isValid) {\n      errors.push(`Missing environment variables: ${envCheck.missing.join(', ')}`)\n    }\n  } catch (error) {\n    checks.environment = false\n    errors.push('Environment validation failed')\n  }\n  \n  // TODO: Add more health checks\n  // - Database connectivity\n  // - Webhook endpoint accessibility\n  // - Third-party service status\n  \n  return {\n    healthy: Object.values(checks).every(Boolean),\n    checks,\n    errors,\n  }\n}\n\n// Export singleton instance\nexport const paymentErrorLogger = PaymentErrorLogger.getInstance()\n\n// Export types\nexport type {\n  PaymentError,\n  RetryConfig,\n}