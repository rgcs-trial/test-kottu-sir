/**\n * Security validation utilities for Stripe payment processing\n * Implements PCI DSS compliance and security best practices\n */\n\nimport { z } from 'zod'\nimport rateLimit from 'express-rate-limit'\n\n// ===== INPUT SANITIZATION =====\n\n/**\n * Sanitize string input to prevent XSS attacks\n */\nexport function sanitizeString(input: string): string {\n  if (typeof input !== 'string') {\n    throw new Error('Input must be a string')\n  }\n  \n  return input\n    .trim()\n    .replace(/[<>\"'&]/g, (char) => {\n      const entityMap: Record<string, string> = {\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#x27;',\n        '&': '&amp;',\n      }\n      return entityMap[char] || char\n    })\n    .substring(0, 1000) // Limit length\n}\n\n/**\n * Sanitize email input\n */\nexport function sanitizeEmail(email: string): string {\n  const sanitized = sanitizeString(email).toLowerCase()\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n  \n  if (!emailRegex.test(sanitized)) {\n    throw new Error('Invalid email format')\n  }\n  \n  return sanitized\n}\n\n/**\n * Sanitize phone number input\n */\nexport function sanitizePhone(phone: string): string {\n  const sanitized = sanitizeString(phone).replace(/[^\\d\\s\\-\\(\\)\\+]/g, '')\n  \n  if (sanitized.length < 10 || sanitized.length > 20) {\n    throw new Error('Invalid phone number length')\n  }\n  \n  return sanitized\n}\n\n/**\n * Sanitize currency amount\n */\nexport function sanitizeCurrency(amount: number): number {\n  if (typeof amount !== 'number' || isNaN(amount)) {\n    throw new Error('Amount must be a valid number')\n  }\n  \n  if (amount < 0) {\n    throw new Error('Amount cannot be negative')\n  }\n  \n  if (amount > 999999.99) {\n    throw new Error('Amount exceeds maximum limit')\n  }\n  \n  // Round to 2 decimal places\n  return Math.round(amount * 100) / 100\n}\n\n// ===== VALIDATION SCHEMAS =====\n\n/**\n * Secure payment data validation schema\n */\nexport const SecurePaymentDataSchema = z.object({\n  amount: z.number()\n    .min(0.5, 'Minimum amount is $0.50')\n    .max(999999.99, 'Amount exceeds maximum limit')\n    .refine((val) => Number.isFinite(val), 'Amount must be a valid number'),\n  \n  currency: z.string()\n    .length(3, 'Currency must be 3 characters')\n    .regex(/^[A-Z]{3}$/, 'Invalid currency format')\n    .default('USD'),\n  \n  restaurantId: z.string().uuid('Invalid restaurant ID'),\n  \n  customerEmail: z.string()\n    .email('Invalid email format')\n    .max(254, 'Email too long')\n    .transform(sanitizeEmail),\n  \n  customerName: z.string()\n    .min(1, 'Name is required')\n    .max(100, 'Name too long')\n    .transform(sanitizeString),\n  \n  customerPhone: z.string()\n    .optional()\n    .transform((val) => val ? sanitizePhone(val) : undefined),\n  \n  orderId: z.string()\n    .uuid('Invalid order ID')\n    .optional(),\n  \n  metadata: z.record(z.string().max(500, 'Metadata value too long'))\n    .refine(\n      (obj) => Object.keys(obj).length <= 20,\n      'Too many metadata fields'\n    )\n    .transform((obj) => {\n      const sanitized: Record<string, string> = {}\n      for (const [key, value] of Object.entries(obj)) {\n        if (typeof value === 'string') {\n          sanitized[sanitizeString(key)] = sanitizeString(value)\n        }\n      }\n      return sanitized\n    })\n    .default({}),\n})\n\n/**\n * Secure customer address validation\n */\nexport const SecureAddressSchema = z.object({\n  street: z.string()\n    .min(1, 'Street is required')\n    .max(200, 'Street too long')\n    .transform(sanitizeString),\n  \n  city: z.string()\n    .min(1, 'City is required')\n    .max(100, 'City too long')\n    .transform(sanitizeString),\n  \n  state: z.string()\n    .min(1, 'State is required')\n    .max(100, 'State too long')\n    .transform(sanitizeString),\n  \n  zipCode: z.string()\n    .min(3, 'ZIP code too short')\n    .max(20, 'ZIP code too long')\n    .transform(sanitizeString),\n  \n  country: z.string()\n    .length(2, 'Country must be 2 characters')\n    .regex(/^[A-Z]{2}$/, 'Invalid country format')\n    .default('US'),\n  \n  instructions: z.string()\n    .max(500, 'Instructions too long')\n    .transform(sanitizeString)\n    .optional(),\n})\n\n// ===== RATE LIMITING =====\n\ninterface RateLimitConfig {\n  windowMs: number\n  max: number\n  message: string\n  skipSuccessfulRequests?: boolean\n  keyGenerator?: (req: any) => string\n}\n\n/**\n * Create rate limiter for payment endpoints\n */\nexport function createPaymentRateLimit(config: RateLimitConfig) {\n  return {\n    windowMs: config.windowMs,\n    max: config.max,\n    message: { error: config.message },\n    skipSuccessfulRequests: config.skipSuccessfulRequests || false,\n    keyGenerator: config.keyGenerator || ((req: any) => {\n      return req.ip || req.headers['x-forwarded-for'] || 'unknown'\n    }),\n  }\n}\n\n/**\n * Rate limits for different payment operations\n */\nexport const PaymentRateLimits = {\n  createPaymentIntent: createPaymentRateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 100, // 100 requests per 15 minutes\n    message: 'Too many payment attempts. Please try again later.',\n    skipSuccessfulRequests: true,\n  }),\n  \n  confirmPayment: createPaymentRateLimit({\n    windowMs: 5 * 60 * 1000, // 5 minutes\n    max: 20, // 20 confirmations per 5 minutes\n    message: 'Too many payment confirmations. Please try again later.',\n  }),\n  \n  webhook: createPaymentRateLimit({\n    windowMs: 1 * 60 * 1000, // 1 minute\n    max: 1000, // 1000 webhooks per minute (Stripe can send many)\n    message: 'Webhook rate limit exceeded.',\n  }),\n  \n  onboarding: createPaymentRateLimit({\n    windowMs: 60 * 60 * 1000, // 1 hour\n    max: 10, // 10 onboarding attempts per hour\n    message: 'Too many onboarding attempts. Please try again later.',\n  }),\n}\n\n// ===== WEBHOOK SECURITY =====\n\n/**\n * Validate webhook signature timing\n */\nexport function validateWebhookTiming(timestamp: string, tolerance = 300): boolean {\n  const webhookTime = parseInt(timestamp, 10) * 1000\n  const now = Date.now()\n  const timeDiff = Math.abs(now - webhookTime)\n  \n  return timeDiff <= tolerance * 1000 // tolerance in seconds\n}\n\n/**\n * Validate webhook source\n */\nexport function validateWebhookSource(userAgent?: string): boolean {\n  if (!userAgent) return false\n  \n  // Stripe webhooks use this user agent pattern\n  return /^Stripe\\//.test(userAgent)\n}\n\n// ===== PAYMENT SECURITY CHECKS =====\n\n/**\n * Check for suspicious payment patterns\n */\nexport function detectSuspiciousPayment({\n  amount,\n  customerEmail,\n  customerName,\n  metadata = {},\n}: {\n  amount: number\n  customerEmail: string\n  customerName: string\n  metadata?: Record<string, string>\n}): { isSuspicious: boolean; reasons: string[] } {\n  const reasons: string[] = []\n  \n  // Check for unusually high amounts\n  if (amount > 10000) {\n    reasons.push('Unusually high payment amount')\n  }\n  \n  // Check for suspicious email patterns\n  const suspiciousEmailPatterns = [\n    /^test[\\d]*@/,\n    /temp.*@/,\n    /disposable.*@/,\n    /10minutemail/,\n    /guerrillamail/,\n  ]\n  \n  if (suspiciousEmailPatterns.some(pattern => pattern.test(customerEmail.toLowerCase()))) {\n    reasons.push('Suspicious email address')\n  }\n  \n  // Check for suspicious name patterns\n  if (customerName.toLowerCase().includes('test') || \n      customerName.toLowerCase().includes('fake') ||\n      /^[a-z]$/.test(customerName.toLowerCase())) {\n    reasons.push('Suspicious customer name')\n  }\n  \n  // Check metadata for testing patterns\n  const metadataString = JSON.stringify(metadata).toLowerCase()\n  if (metadataString.includes('test') || metadataString.includes('fake')) {\n    reasons.push('Test data detected in metadata')\n  }\n  \n  return {\n    isSuspicious: reasons.length > 0,\n    reasons,\n  }\n}\n\n/**\n * Validate payment method security\n */\nexport function validatePaymentMethodSecurity(paymentMethodId: string): boolean {\n  // Basic Stripe payment method ID format validation\n  return /^pm_[a-zA-Z0-9]{24,}$/.test(paymentMethodId)\n}\n\n// ===== LOGGING & MONITORING =====\n\n/**\n * Security event types\n */\nexport enum SecurityEventType {\n  SUSPICIOUS_PAYMENT = 'suspicious_payment',\n  RATE_LIMIT_EXCEEDED = 'rate_limit_exceeded',\n  INVALID_WEBHOOK_SIGNATURE = 'invalid_webhook_signature',\n  WEBHOOK_TIMING_VIOLATION = 'webhook_timing_violation',\n  LARGE_PAYMENT_ATTEMPT = 'large_payment_attempt',\n  REPEATED_FAILED_PAYMENTS = 'repeated_failed_payments',\n  UNUSUAL_CUSTOMER_BEHAVIOR = 'unusual_customer_behavior',\n}\n\n/**\n * Log security event\n */\nexport function logSecurityEvent(\n  eventType: SecurityEventType,\n  details: Record<string, any>,\n  severity: 'low' | 'medium' | 'high' | 'critical' = 'medium'\n): void {\n  const event = {\n    timestamp: new Date().toISOString(),\n    type: eventType,\n    severity,\n    details: {\n      ...details,\n      // Remove sensitive data\n      paymentIntentId: details.paymentIntentId ? 'pi_***' + details.paymentIntentId.slice(-4) : undefined,\n      customerEmail: details.customerEmail ? details.customerEmail.replace(/(.{2}).*(@.*)/, '$1***$2') : undefined,\n    },\n    userAgent: details.userAgent,\n    ip: details.ip,\n  }\n  \n  // In production, send to security monitoring service\n  console.warn('Security Event:', JSON.stringify(event, null, 2))\n  \n  // For critical events, consider immediate alerting\n  if (severity === 'critical') {\n    // TODO: Send immediate alert to security team\n    console.error('CRITICAL SECURITY EVENT:', event)\n  }\n}\n\n// ===== ENVIRONMENT VALIDATION =====\n\n/**\n * Validate required environment variables\n */\nexport function validateEnvironment(): { isValid: boolean; missing: string[] } {\n  const required = [\n    'STRIPE_SECRET_KEY',\n    'NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY',\n    'STRIPE_WEBHOOK_SECRET',\n  ]\n  \n  const missing = required.filter(key => !process.env[key])\n  \n  return {\n    isValid: missing.length === 0,\n    missing,\n  }\n}\n\n/**\n * Check if running in production environment\n */\nexport function isProduction(): boolean {\n  return process.env.NODE_ENV === 'production'\n}\n\n/**\n * Get secure headers for payment responses\n */\nexport function getSecureHeaders(): Record<string, string> {\n  return {\n    'X-Content-Type-Options': 'nosniff',\n    'X-Frame-Options': 'DENY',\n    'X-XSS-Protection': '1; mode=block',\n    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',\n    'Referrer-Policy': 'strict-origin-when-cross-origin',\n    'Cache-Control': 'no-store, no-cache, must-revalidate, private',\n    'Pragma': 'no-cache',\n    'Expires': '0',\n  }\n}\n\n// Export types\nexport type {\n  RateLimitConfig,\n}\n\n// Export validation schemas\nexport {\n  SecurePaymentDataSchema,\n  SecureAddressSchema,\n}