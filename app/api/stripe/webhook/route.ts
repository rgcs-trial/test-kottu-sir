import { NextRequest, NextResponse } from 'next/server'
import { headers } from 'next/headers'
import { constructWebhookEvent, webhookHandlers } from '@/lib/stripe/server'
import { createClient } from '@/lib/supabase/server'
import Stripe from 'stripe'

// Webhook endpoint configuration
const WEBHOOK_SECRET = process.env.STRIPE_WEBHOOK_SECRET!

if (!WEBHOOK_SECRET) {\n  throw new Error('Missing STRIPE_WEBHOOK_SECRET environment variable')\n}\n\n/**\n * POST /api/stripe/webhook\n * Handle Stripe webhook events with signature verification\n */\nexport async function POST(request: NextRequest): Promise<NextResponse> {\n  try {\n    // Get raw body and signature\n    const body = await request.text()\n    const headersList = headers()\n    const signature = headersList.get('stripe-signature')\n    \n    if (!signature) {\n      console.error('Missing stripe-signature header')\n      return NextResponse.json(\n        { error: 'Missing signature' },\n        { status: 400 }\n      )\n    }\n    \n    // Verify webhook signature\n    let event: Stripe.Event\n    try {\n      event = constructWebhookEvent(body, signature, WEBHOOK_SECRET)\n    } catch (err) {\n      console.error('Webhook signature verification failed:', err)\n      return NextResponse.json(\n        { error: 'Invalid signature' },\n        { status: 400 }\n      )\n    }\n    \n    // Log webhook event\n    console.log(`Webhook received: ${event.type} - ${event.id}`)\n    \n    // Get Supabase client for database operations\n    const supabase = createClient()\n    \n    // Handle the event\n    try {\n      await handleWebhookEvent(event, supabase)\n    } catch (error) {\n      console.error(`Error handling webhook event ${event.type}:`, error)\n      // Return 200 to prevent Stripe from retrying, but log the error\n      return NextResponse.json(\n        { \n          received: true, \n          error: 'Event processing failed',\n          eventId: event.id,\n        },\n        { status: 200 }\n      )\n    }\n    \n    // Acknowledge receipt of the event\n    return NextResponse.json(\n      { received: true, eventId: event.id },\n      { status: 200 }\n    )\n    \n  } catch (error) {\n    console.error('Webhook endpoint error:', error)\n    return NextResponse.json(\n      { error: 'Webhook processing failed' },\n      { status: 500 }\n    )\n  }\n}\n\n/**\n * Handle individual webhook events\n */\nasync function handleWebhookEvent(event: Stripe.Event, supabase: any): Promise<void> {\n  switch (event.type) {\n    case 'payment_intent.succeeded':\n      await handlePaymentIntentSucceeded(event.data.object as Stripe.PaymentIntent, supabase)\n      break\n      \n    case 'payment_intent.payment_failed':\n      await handlePaymentIntentFailed(event.data.object as Stripe.PaymentIntent, supabase)\n      break\n      \n    case 'payment_intent.requires_action':\n      await handlePaymentIntentRequiresAction(event.data.object as Stripe.PaymentIntent, supabase)\n      break\n      \n    case 'account.updated':\n      await handleAccountUpdated(event.data.object as Stripe.Account, supabase)\n      break\n      \n    case 'capability.updated':\n      await handleCapabilityUpdated(event.data.object as Stripe.Capability, supabase)\n      break\n      \n    case 'transfer.paid':\n      await handleTransferPaid(event.data.object as Stripe.Transfer, supabase)\n      break\n      \n    case 'payout.paid':\n      await handlePayoutPaid(event.data.object as Stripe.Payout, supabase)\n      break\n      \n    case 'charge.dispute.created':\n      await handleDisputeCreated(event.data.object as Stripe.Dispute, supabase)\n      break\n      \n    // Subscription events\n    case 'customer.subscription.created':\n    case 'customer.subscription.updated':\n    case 'customer.subscription.deleted':\n    case 'invoice.payment_succeeded':\n    case 'invoice.payment_failed':\n      // Use existing handlers from server.ts\n      const handler = webhookHandlers[event.type as keyof typeof webhookHandlers]\n      if (handler) {\n        await handler(event.data.object as any)\n      }\n      break\n      \n    default:\n      console.log(`Unhandled event type: ${event.type}`)\n  }\n}\n\n/**\n * Handle successful payment\n */\nasync function handlePaymentIntentSucceeded(\n  paymentIntent: Stripe.PaymentIntent,\n  supabase: any\n): Promise<void> {\n  const { orderId, restaurantId } = paymentIntent.metadata || {}\n  \n  if (!orderId) {\n    console.warn('Payment succeeded but no orderId in metadata:', paymentIntent.id)\n    return\n  }\n  \n  try {\n    // Update order status to confirmed and payment status to paid\n    const { error } = await supabase\n      .from('orders')\n      .update({\n        status: 'confirmed',\n        payment_status: 'paid',\n        payment_intent_id: paymentIntent.id,\n        updated_at: new Date().toISOString(),\n      })\n      .eq('id', orderId)\n    \n    if (error) {\n      console.error('Error updating order after payment success:', error)\n      return\n    }\n    \n    console.log(`Order ${orderId} confirmed after successful payment ${paymentIntent.id}`)\n    \n    // TODO: Send confirmation email to customer\n    // TODO: Notify restaurant of new order\n    // TODO: Update inventory if tracking is enabled\n    \n  } catch (error) {\n    console.error('Error handling payment success:', error)\n  }\n}\n\n/**\n * Handle failed payment\n */\nasync function handlePaymentIntentFailed(\n  paymentIntent: Stripe.PaymentIntent,\n  supabase: any\n): Promise<void> {\n  const { orderId } = paymentIntent.metadata || {}\n  \n  if (!orderId) {\n    console.warn('Payment failed but no orderId in metadata:', paymentIntent.id)\n    return\n  }\n  \n  try {\n    // Update order payment status to failed\n    const { error } = await supabase\n      .from('orders')\n      .update({\n        payment_status: 'failed',\n        updated_at: new Date().toISOString(),\n      })\n      .eq('id', orderId)\n    \n    if (error) {\n      console.error('Error updating order after payment failure:', error)\n      return\n    }\n    \n    console.log(`Order ${orderId} payment failed: ${paymentIntent.id}`)\n    \n    // TODO: Send payment failure notification to customer\n    // TODO: Handle inventory release if items were reserved\n    \n  } catch (error) {\n    console.error('Error handling payment failure:', error)\n  }\n}\n\n/**\n * Handle payment requiring action (3D Secure, etc.)\n */\nasync function handlePaymentIntentRequiresAction(\n  paymentIntent: Stripe.PaymentIntent,\n  supabase: any\n): Promise<void> {\n  const { orderId } = paymentIntent.metadata || {}\n  \n  if (!orderId) {\n    console.warn('Payment requires action but no orderId in metadata:', paymentIntent.id)\n    return\n  }\n  \n  try {\n    // Update order to indicate action is required\n    const { error } = await supabase\n      .from('orders')\n      .update({\n        payment_status: 'pending',\n        updated_at: new Date().toISOString(),\n      })\n      .eq('id', orderId)\n    \n    if (error) {\n      console.error('Error updating order for required action:', error)\n      return\n    }\n    \n    console.log(`Order ${orderId} payment requires action: ${paymentIntent.id}`)\n    \n    // TODO: Notify customer that additional action is required\n    \n  } catch (error) {\n    console.error('Error handling payment requires action:', error)\n  }\n}\n\n/**\n * Handle Connect account updates\n */\nasync function handleAccountUpdated(\n  account: Stripe.Account,\n  supabase: any\n): Promise<void> {\n  try {\n    // Find restaurant by Stripe account ID\n    const { data: restaurant, error: findError } = await supabase\n      .from('restaurants')\n      .select('id')\n      .eq('stripe_connect_account_id', account.id)\n      .single()\n    \n    if (findError || !restaurant) {\n      console.warn('Account updated but no restaurant found:', account.id)\n      return\n    }\n    \n    // Update restaurant with account status\n    const canAcceptPayments = account.capabilities?.card_payments === 'active' &&\n                             account.capabilities?.transfers === 'active'\n    \n    const { error } = await supabase\n      .from('restaurants')\n      .update({\n        stripe_account_status: {\n          charges_enabled: account.charges_enabled,\n          payouts_enabled: account.payouts_enabled,\n          capabilities: account.capabilities,\n          requirements: account.requirements,\n          can_accept_payments: canAcceptPayments,\n        },\n        updated_at: new Date().toISOString(),\n      })\n      .eq('id', restaurant.id)\n    \n    if (error) {\n      console.error('Error updating restaurant account status:', error)\n      return\n    }\n    \n    console.log(`Restaurant account updated: ${account.id} - can_accept_payments: ${canAcceptPayments}`)\n    \n  } catch (error) {\n    console.error('Error handling account update:', error)\n  }\n}\n\n/**\n * Handle capability updates\n */\nasync function handleCapabilityUpdated(\n  capability: Stripe.Capability,\n  supabase: any\n): Promise<void> {\n  try {\n    // Find restaurant by Stripe account ID\n    const { data: restaurant, error: findError } = await supabase\n      .from('restaurants')\n      .select('id, stripe_account_status')\n      .eq('stripe_connect_account_id', capability.account)\n      .single()\n    \n    if (findError || !restaurant) {\n      console.warn('Capability updated but no restaurant found:', capability.account)\n      return\n    }\n    \n    // Update capability in restaurant status\n    const currentStatus = restaurant.stripe_account_status || {}\n    const updatedCapabilities = {\n      ...currentStatus.capabilities,\n      [capability.id]: capability.status,\n    }\n    \n    const { error } = await supabase\n      .from('restaurants')\n      .update({\n        stripe_account_status: {\n          ...currentStatus,\n          capabilities: updatedCapabilities,\n        },\n        updated_at: new Date().toISOString(),\n      })\n      .eq('id', restaurant.id)\n    \n    if (error) {\n      console.error('Error updating restaurant capability:', error)\n      return\n    }\n    \n    console.log(`Restaurant capability updated: ${capability.account} - ${capability.id}: ${capability.status}`)\n    \n  } catch (error) {\n    console.error('Error handling capability update:', error)\n  }\n}\n\n/**\n * Handle successful transfer to restaurant\n */\nasync function handleTransferPaid(\n  transfer: Stripe.Transfer,\n  supabase: any\n): Promise<void> {\n  try {\n    console.log(`Transfer paid: ${transfer.id} - ${transfer.amount / 100} ${transfer.currency}`)\n    \n    // TODO: Log transfer in restaurant payout history\n    // TODO: Update restaurant balance/earnings\n    \n  } catch (error) {\n    console.error('Error handling transfer paid:', error)\n  }\n}\n\n/**\n * Handle successful payout\n */\nasync function handlePayoutPaid(\n  payout: Stripe.Payout,\n  supabase: any\n): Promise<void> {\n  try {\n    console.log(`Payout completed: ${payout.id} - ${payout.amount / 100} ${payout.currency}`)\n    \n    // TODO: Update restaurant payout records\n    // TODO: Send payout confirmation to restaurant\n    \n  } catch (error) {\n    console.error('Error handling payout paid:', error)\n  }\n}\n\n/**\n * Handle charge disputes\n */\nasync function handleDisputeCreated(\n  dispute: Stripe.Dispute,\n  supabase: any\n): Promise<void> {\n  try {\n    console.log(`Dispute created: ${dispute.id} - ${dispute.amount / 100} ${dispute.currency}`)\n    \n    // TODO: Create dispute record in database\n    // TODO: Notify restaurant of dispute\n    // TODO: Provide dispute management tools\n    \n  } catch (error) {\n    console.error('Error handling dispute creation:', error)\n  }\n}\n\n/**\n * GET /api/stripe/webhook\n * Health check endpoint\n */\nexport async function GET(): Promise<NextResponse> {\n  return NextResponse.json(\n    {\n      message: 'Stripe webhook endpoint',\n      methods: ['POST'],\n      version: '1.0.0',\n    },\n    { status: 200 }\n  )\n}