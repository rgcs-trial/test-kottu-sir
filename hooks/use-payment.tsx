'use client'

import { useCallback, useState } from 'react'
import { useStripe, useElements } from '@stripe/react-stripe-js'

// Payment processing types
interface PaymentData {\n  amount: number\n  currency?: string\n  restaurantId: string\n  orderId?: string\n  customerEmail: string\n  customerName: string\n  customerPhone?: string\n  items?: Array<{\n    id: string\n    name: string\n    price: number\n    quantity: number\n  }>\n  savePaymentMethod?: boolean\n  customerDetails?: {\n    email: string\n    name: string\n    phone?: string\n    address?: {\n      street: string\n      city: string\n      state: string\n      zipCode: string\n      country: string\n      instructions?: string\n    }\n  }\n  metadata?: Record<string, string>\n}\n\ninterface PaymentResult {\n  success: boolean\n  paymentIntentId?: string\n  orderId?: string\n  requiresAction?: boolean\n  clientSecret?: string\n  error?: string\n  code?: string\n}\n\ninterface UsePaymentReturn {\n  isProcessing: boolean\n  error: string | null\n  createPaymentIntent: (data: PaymentData) => Promise<{\n    clientSecret: string\n    paymentIntentId: string\n    customerId: string\n    platformFee: number\n  }>\n  confirmPayment: (data: {\n    elements: any\n    confirmParams?: {\n      return_url?: string\n    }\n    paymentData?: PaymentData\n  }) => Promise<PaymentResult>\n  processPayment: (data: PaymentData) => Promise<PaymentResult>\n  clearError: () => void\n}\n\n/**\n * Hook for payment processing\n */\nexport function usePayment(): UsePaymentReturn {\n  const stripe = useStripe()\n  const elements = useElements()\n  const [isProcessing, setIsProcessing] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  \n  const createPaymentIntent = useCallback(async (data: PaymentData) => {\n    try {\n      setError(null)\n      \n      const response = await fetch('/api/stripe/create-payment-intent', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(data),\n      })\n      \n      const result = await response.json()\n      \n      if (!response.ok) {\n        throw new Error(result.error || 'Failed to create payment intent')\n      }\n      \n      return result.data\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to create payment intent'\n      setError(errorMessage)\n      throw new Error(errorMessage)\n    }\n  }, [])\n  \n  const confirmPayment = useCallback(async ({\n    elements: elementsOverride,\n    confirmParams = {},\n    paymentData,\n  }: {\n    elements: any\n    confirmParams?: {\n      return_url?: string\n    }\n    paymentData?: PaymentData\n  }): Promise<PaymentResult> => {\n    try {\n      setIsProcessing(true)\n      setError(null)\n      \n      if (!stripe) {\n        throw new Error('Stripe not loaded')\n      }\n      \n      const elementsToUse = elementsOverride || elements\n      if (!elementsToUse) {\n        throw new Error('Elements not initialized')\n      }\n      \n      // Confirm the payment with Stripe\n      const { error: stripeError, paymentIntent } = await stripe.confirmPayment({\n        elements: elementsToUse,\n        confirmParams: {\n          return_url: `${window.location.origin}/payment/complete`,\n          ...confirmParams,\n        },\n        redirect: 'if_required',\n      })\n      \n      if (stripeError) {\n        throw new Error(stripeError.message || 'Payment confirmation failed')\n      }\n      \n      if (!paymentIntent) {\n        throw new Error('Payment intent not returned')\n      }\n      \n      // Handle the payment result\n      if (paymentIntent.status === 'requires_action') {\n        return {\n          success: false,\n          paymentIntentId: paymentIntent.id,\n          requiresAction: true,\n          clientSecret: paymentIntent.client_secret || undefined,\n          error: 'Additional authentication required',\n          code: 'REQUIRES_ACTION',\n        }\n      }\n      \n      if (paymentIntent.status === 'succeeded') {\n        // Confirm with our backend\n        try {\n          const confirmResponse = await fetch('/api/stripe/confirm-payment', {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n              paymentIntentId: paymentIntent.id,\n              customerDetails: paymentData?.customerDetails,\n              savePaymentMethod: paymentData?.savePaymentMethod || false,\n            }),\n          })\n          \n          const confirmResult = await confirmResponse.json()\n          \n          if (!confirmResponse.ok) {\n            console.warn('Backend confirmation failed:', confirmResult.error)\n            // Payment succeeded with Stripe but backend confirmation failed\n            // This needs careful handling in production\n          }\n          \n          return {\n            success: true,\n            paymentIntentId: paymentIntent.id,\n            orderId: confirmResult.data?.orderId,\n            requiresAction: false,\n          }\n        } catch (confirmError) {\n          console.warn('Backend confirmation error:', confirmError)\n          // Payment succeeded with Stripe\n          return {\n            success: true,\n            paymentIntentId: paymentIntent.id,\n            requiresAction: false,\n            error: 'Payment succeeded but confirmation failed',\n          }\n        }\n      }\n      \n      // Other statuses\n      return {\n        success: false,\n        paymentIntentId: paymentIntent.id,\n        error: `Payment ${paymentIntent.status}`,\n        code: paymentIntent.status,\n      }\n      \n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Payment failed'\n      setError(errorMessage)\n      return {\n        success: false,\n        error: errorMessage,\n        code: 'PAYMENT_ERROR',\n      }\n    } finally {\n      setIsProcessing(false)\n    }\n  }, [stripe, elements])\n  \n  const processPayment = useCallback(async (data: PaymentData): Promise<PaymentResult> => {\n    try {\n      setIsProcessing(true)\n      setError(null)\n      \n      // Step 1: Create payment intent\n      const intentData = await createPaymentIntent(data)\n      \n      // Step 2: Confirm payment\n      const result = await confirmPayment({\n        elements,\n        paymentData: data,\n      })\n      \n      return result\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Payment processing failed'\n      setError(errorMessage)\n      return {\n        success: false,\n        error: errorMessage,\n        code: 'PAYMENT_PROCESSING_ERROR',\n      }\n    } finally {\n      setIsProcessing(false)\n    }\n  }, [createPaymentIntent, confirmPayment, elements])\n  \n  const clearError = useCallback(() => {\n    setError(null)\n  }, [])\n  \n  return {\n    isProcessing,\n    error,\n    createPaymentIntent,\n    confirmPayment,\n    processPayment,\n    clearError,\n  }\n}\n\n// Refund processing hook\ninterface UseRefundReturn {\n  isProcessing: boolean\n  error: string | null\n  createRefund: (data: {\n    paymentIntentId: string\n    amount?: number\n    reason?: 'duplicate' | 'fraudulent' | 'requested_by_customer'\n  }) => Promise<{\n    refundId: string\n    amount: number\n    status: string\n    currency: string\n  }>\n  clearError: () => void\n}\n\n/**\n * Hook for processing refunds\n */\nexport function useRefund(): UseRefundReturn {\n  const [isProcessing, setIsProcessing] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  \n  const createRefund = useCallback(async (data: {\n    paymentIntentId: string\n    amount?: number\n    reason?: 'duplicate' | 'fraudulent' | 'requested_by_customer'\n  }) => {\n    try {\n      setIsProcessing(true)\n      setError(null)\n      \n      const response = await fetch('/api/stripe/refund', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(data),\n      })\n      \n      const result = await response.json()\n      \n      if (!response.ok) {\n        throw new Error(result.error || 'Refund failed')\n      }\n      \n      return result.data\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Refund processing failed'\n      setError(errorMessage)\n      throw new Error(errorMessage)\n    } finally {\n      setIsProcessing(false)\n    }\n  }, [])\n  \n  const clearError = useCallback(() => {\n    setError(null)\n  }, [])\n  \n  return {\n    isProcessing,\n    error,\n    createRefund,\n    clearError,\n  }\n}\n\n// Payment validation hook\ninterface UsePaymentValidationReturn {\n  validateCard: (cardElement: any) => Promise<boolean>\n  validateForm: (data: Partial<PaymentData>) => {\n    isValid: boolean\n    errors: Record<string, string>\n  }\n  formatCardError: (error: any) => string\n}\n\n/**\n * Hook for payment validation\n */\nexport function usePaymentValidation(): UsePaymentValidationReturn {\n  const stripe = useStripe()\n  \n  const validateCard = useCallback(async (cardElement: any): Promise<boolean> => {\n    if (!stripe || !cardElement) {\n      return false\n    }\n    \n    try {\n      const { error } = await stripe.createPaymentMethod({\n        type: 'card',\n        card: cardElement,\n      })\n      \n      return !error\n    } catch {\n      return false\n    }\n  }, [stripe])\n  \n  const validateForm = useCallback((data: Partial<PaymentData>) => {\n    const errors: Record<string, string> = {}\n    \n    if (!data.amount || data.amount <= 0) {\n      errors.amount = 'Amount must be greater than 0'\n    }\n    \n    if (!data.customerEmail) {\n      errors.customerEmail = 'Email is required'\n    } else if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.customerEmail)) {\n      errors.customerEmail = 'Please enter a valid email address'\n    }\n    \n    if (!data.customerName || data.customerName.trim().length < 2) {\n      errors.customerName = 'Name must be at least 2 characters'\n    }\n    \n    if (!data.restaurantId) {\n      errors.restaurantId = 'Restaurant ID is required'\n    }\n    \n    if (data.customerPhone && !/^[\\d\\s\\-\\(\\)\\+]{10,}$/.test(data.customerPhone)) {\n      errors.customerPhone = 'Please enter a valid phone number'\n    }\n    \n    return {\n      isValid: Object.keys(errors).length === 0,\n      errors,\n    }\n  }, [])\n  \n  const formatCardError = useCallback((error: any): string => {\n    if (!error) return ''\n    \n    switch (error.code) {\n      case 'incomplete_number':\n        return 'Your card number is incomplete.'\n      case 'incomplete_cvc':\n        return 'Your card\\'s security code is incomplete.'\n      case 'incomplete_expiry':\n        return 'Your card\\'s expiration date is incomplete.'\n      case 'invalid_number':\n        return 'Your card number is invalid.'\n      case 'invalid_expiry_month':\n        return 'Your card\\'s expiration month is invalid.'\n      case 'invalid_expiry_year':\n        return 'Your card\\'s expiration year is invalid.'\n      case 'invalid_cvc':\n        return 'Your card\\'s security code is invalid.'\n      case 'expired_card':\n        return 'Your card has expired.'\n      case 'card_declined':\n        return 'Your card was declined.'\n      case 'insufficient_funds':\n        return 'Your card has insufficient funds.'\n      case 'processing_error':\n        return 'An error occurred while processing your card. Try again.'\n      default:\n        return error.message || 'An error occurred with your payment method.'\n    }\n  }, [])\n  \n  return {\n    validateCard,\n    validateForm,\n    formatCardError,\n  }\n}\n\n// Export types\nexport type {\n  PaymentData,\n  PaymentResult,\n  UsePaymentReturn,\n  UseRefundReturn,\n  UsePaymentValidationReturn,\n}